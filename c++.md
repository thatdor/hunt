[TOC]
# C/C++
## const
1. 修饰变量，说明该变量不可以被改变；
2. 修饰指针，分为指向常量的指针和指针常量；
3. 常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；
4. 修饰成员函数，说明该成员函数内不能修改成员变量。
```
// 类
class A
{
private:
    const int a;                // 常对象成员，只能在初始化列表赋值

public:
    // 构造函数
    A() { }
    A(int x) : a(x) { }        // 初始化列表

    // const可用于对重载函数的区分
    int getValue();             // 普通成员函数
    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值
};

void function()
{
    // 对象
    A b;                        // 普通对象，可以调用全部成员函数
    const A a;                  // 常对象，只能调用常成员函数、更新常成员变量
    const A *p = &a;            // 常指针
    const A &q = a;             // 常引用

    // 指针
    char greeting[] = "Hello";
    char* p1 = greeting;                // 指针变量，指向字符数组变量
    const char* p2 = greeting;          // 指针变量，指向字符数组常量
    char* const p3 = greeting;          // 常指针，指向字符数组变量
    const char* const p4 = greeting;    // 常指针，指向字符数组常量
}

// 函数
void function1(const int Var);           // 传递过来的参数在函数内不可变
void function2(const char* Var);         // 参数指针所指内容为常量
void function3(char* const Var);         // 参数指针为常指针
void function4(const int& Var);          // 引用参数在函数内为常量

// 函数返回值
const int function5();      // 返回一个常数
const int* function6();     // 返回一个指向常量的指针变量，使用：const int *p = function6();
int* const function7();     // 返回一个指向变量的常指针，使用：int* const p = function7();
```
## static
1. 修饰普通变量，修改**变量的存储区域**和**生命周期**，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
2. 修饰普通函数，**表明函数的作用范围**，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命令函数重名，可以将函数定位为 static。
3. 修饰成员变量，修饰成员变量使所有的对象**只保存一个该变量**，而且**不需要生成对象**就可以访问该成员。
4. 修饰成员函数，修饰成员函数使得**不需要生成对象**就可以访问该函数，但是在 static 函数内**不能访问非静态成员**。

## this指针
1. `this`指针是一个隐含于**每一个非静态成员函数**的特殊指针。它指向正在被该成员函数操作的那个对象。
2. 当对一个对象调用成员函数时，编译程序先将对象的地址赋给`this`指针，然后调用成员函数。每次成员函数存取数据成员时，都隐含使用`this`指针。
3. 当一个成员函数被调用时，自动向它传递一个隐含参数，该参数是一个指向该成员函数所在对象的指针。
4. `this`指针被隐含地声明为`ClassName *const this`，意味着不能给`this`指针赋值；在`const`成员函数中，`this`指针的类型为`const ClassName* const`，说明`this`所指对象是不可修改的（即不能对该对象的数据成员进行赋值操作）。
5. `this`不是常规变量，而是个**右值**，所以不能取`this`地址。
6. 在以下场景中，经常显示引用`this`指针：
    - 为实现对象的链式引用；
    - 为避免对同一对象进行赋值操作；
    - 在实现一些数据结构时，如list。
## inline内联函数
### 特征
- 相当于把内联函数里面的内容写在调用内联函数处；

- 相当于不用执行进入函数的步骤，直接执行函数体；
- 相当于宏，却比宏多了类型检查，真正具有函数特性；
- 不能包含循环、递归、switch 等复杂操作；
- 在类声明中定义的函数，**除了虚函数的其他函数**都会自动隐式地当成内联函数。
### 使用
```
// 声明1（加 inline，建议使用）
inline int functionName(int first, int secend,...);

// 声明2（不加 inline）
int functionName(int first, int secend,...);

// 定义
inline int functionName(int first, int secend,...) {/****/};

// 类内定义，隐式内联
class A {
    int doA() { return 0; }         // 隐式内联
}

// 类外定义，需要显式内联
class A {
    int doA();
}
inline int A::doA() { return 0; }   // 需要显式内联
```
### 编译器对inline函数的处理步骤
1. 将inline函数体复制到inline函数调用点处
2. 为所用inline函数中的局部变量分配内存空间
3. 将inline函数的入参和返回值映射到调用方法的局部变量空间中
4. 如果inline函数有多个返回点，将其转变为inline函数代码块末尾的分支（使用GOTO）

### 优缺点
#### 优点
1. inline函数如同宏函数一样将在被调用处进行**代码展开**，省去了**参数压栈**、**栈帧开辟与回收**、**结果返回**等，从而提高程序**运行速度**。
2. 相比宏函数来说，在代码展开时会进行**安全检查**或**自动类型转换**（同普通函数），而宏定义不会。
3. 在类中声明同时定义的成员函数，自动转换为内联函数，因此内联函数可以访问类的成员变量，宏定义不能。
4. 内联函数在运行时可调试，宏定义不能。
#### 缺点
1. **代码膨胀**。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，则效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序总代码量增大，消耗更多内存空间。
2. inline函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像non-inline可以直接链接。
3. 是否内联，程序员不可控。inline只是对编译器的建议，是否对函数内联，决定权在于编译器。
#### 虚函数（virtual）可否内联
+ 虚函数可以内联，但是当虚函数表现多态性的时候不能内联。
+ 内联是在编译期建议compiler内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因而表现多态性时（运行期）不可内联。
+ `inline virtual` 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 `Base::who()`），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。
#### 虚函数内联使用
```
#include <iostream>  
using namespace std;
class Base
{
public:
    inline virtual void who()
    {
        cout << "I am Base\n";
    }
    virtual ~Base() {}
};
class Derived : public Base
{
public:
    inline void who()  // 不写inline时隐式内联
    {
        cout << "I am Derived\n";
    }
};

int main()
{
    // 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，
    // 所以它可以是内联的，但最终是否内联取决于编译器。 
    Base b;
    b.who();

    // 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  
    Base *ptr = new Derived();
    ptr->who();

    // 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，
    // 会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。
    delete ptr;
    ptr = nullptr;

    system("pause");
    return 0;
} 
```
## #pragma pack(n)
设定结构体、联合及类成员变量以n字节方式对齐
```
#pragma pack(push)  // 保存对齐状态
#pragma pack(4)     // 设定为 4 字节对齐

struct test
{
    char m1;
    double m4;
    int m3;
};

#pragma pack(pop)   // 恢复对齐状态
```
## 位域
类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。
- 位域在内存中的布局是与机器有关的
- 位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定
- 取地址运算符（&）不能作用于位域，任何指针都无法指向类的位域

## volatile
+ volatile关键字是一种**类型修饰符**，用它声明的类型变量可被某些编译器未知的因素（操作系统、硬件、其他线程etc）更改，使用volatile即告诉编译器不应对这样的对象进行优化。
+ volatile声明的变量，每次访问必须从内存中取值（others可能由于编译器的优化，从CPU寄存器中取值）。
+ const可以是volatile（如只读的状态寄存器）。
+ 指针可以是volatile。

## extern "C"
- 被`extern "C"`修饰的变量和函数是按照C语言的方式进行编译和连接的，extern "C" 的作用是让 C++ 编译器将 extern "C" 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。
```
#ifdef __cplusplus
extern "C" {
#endif

void *memset(void *, int, size_t);

#ifdef __cplusplus
}
#endif
```

## GP与OOP

GP（Generic Programming）类属编程/泛型编程，OOP（Object Oriented Programming）。

类属编程是构成库的另一种方式， 这与传统的oop是不同的。这类程序库一般由类属组件和类属算法组成，**组件和算法**通过迭代器组装起来，组件则对迭代器提供一定的封装。这种程序库的优点在于能够提供比传统程序库更灵活的组装方式，而不损失效率。广义的，将泛型程序设计描述为“利用**模板**设计的程序”（programming with template），将面向对象程序设计描述为“利用**继承**的程序设计”（programming with inheritance）。

不严谨的情况下，泛型编程与面向对象编程间接地与模板和继承有关系。严谨的说：泛型程序设计基于参数化多态（parametric polymorphism），面向对象程序设计基于子类型多态（subtype polymorphism）。在C++中这些观念通过模板和继承实现，而在其他语言中其实现机制并非如此。

**比较**

1. 速度：虚函数比函数模板慢。

   虚函数调用<模板=普通函数调用。

2. 运行时分派vs编译时分派

   虚函数的运行时分派（run-time dispatch）和继承是oop的最显著特征之一。模板不提供运行时分派，但提供编译时显著的灵活性；事实上，当编译能够在编译时执行时，模板比继承提供了更多的灵活性。因为他们不需要模板参数类型继承自某些基类。

3. 代码大小：虚函数小，模板大。

4. 二元方法问题

## C与C++对比

1. 设计理念不同，C++允许大家使用各种编程范式。
   - 支持c语言中的**面向过程**的编程范式
   - 支持面向对象的编程范式，使得我们可以抽象问题本身，通过定义抽象数据类型来抽象问题，封装问题对应的数据在类作用域内，然后可以合理而非滥用oop思想的封装、继承、多态来使得代码更易维护。
   - 模板的引用，可进行**泛型编程**；



# 算法

## 排序

[十大经典排序算法动画与解析](https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247484184&idx=1&sn=62965b401aa42107b3c17d1d8ea17454&chksm=fa0e6c99cd79e58f298e9026f677f912bd8c8e55edb48fc509b2b5834f05e529a9b47d59d202&scene=21#wechat_redirect)

- 快速排序

  ```
  选择一个目标值，比目标值小的放左边，比目标值大的放右边，目标值的位置已排好，将左右两侧再进行快排。
  ```

- 归并排序

  ```
  将大序列二分成小序列，将小序列排序后再将排序后的小序列归并成大序列。
  ```

  

- 选择排序

  ```
  每次排序取一个最大或最小的数字放到前面的有序序列中。
  ```

  

- 插入排序

  ```
  将左侧序列看成一个有序序列，每次将一个数字插入该有序序列。插入时，从有序序列最右侧开始比较，若比较的数较大，后移一位。
  ```

  

- 冒泡排序

  ```
  循环数组，比较当前元素和下一个元素，如果当前元素比下一个元素大，向上冒泡。下一次循环继续上面的操作，不循环已经排序好的数。
  ```

  冒泡优化方案： 在第一层循环内设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成

- 堆排序

  ```
  创建一个大顶堆，大顶堆的堆顶一定是最大的元素。交换第一个元素和最后一个元素，让剩余的元素继续调整为大顶堆。从后往前以此和第一个元素交换并重新构建，排序完成。
  ```

  

